// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`io model 1`] = `
"/**
 * Code generated by github.com/macoolka/macoolka-gen-model, DO NOT EDIT.
 */
import * as t from 'macoolka-io'
/**
 * The define  basic info for scalar 
 * @desczh
 * 定义一个标量的基本信息
 */
export const MScalable =t.type({
  /**
   * The Node can be marked as undefined. 
   * @desczh
   * 可能为空
   */
  maybe:t.withDefault(t.boolean,false),
  /**
   * The field has the many multiplicity will also be marked.
   * @desczh
   * 是否是数组
   */
  isArray:t.withDefault(t.boolean,false),
  /**
   * The field is T | Array<T>.
   * @desczh
   * T | Array<T>
   */
  maybeArray:t.withDefault(t.boolean,false),
  /**
   * The means that no item in the list can be null
   * @desczh
   * 非空数组
   */
  isArrayRequired:t.withDefault(t.boolean,false),
  /**
   * The means that defaultValue is []
   * @desczh
   * 缺省值为[]
   */
  defaultEmptyArray:t.withDefault(t.boolean,true),
})
 
/**
 * Like a Boolean an Enum can have one of a predefined set of values.
 * The difference is that you can define the possible values
 * (whereas for a Boolean the options are restriced to true and false).
 * For example you could specify how an article should be formatted
 * by creating an Enum with the possible values COMPACT, WIDE and COVER.
 * @desczh
 * 枚举类型
 */
export const MEnumScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Scalar be used.
     * @desczh
     * 标签判断哪一个Scalar被使用
     */
    _kind:t.literal('enum'),
    /**
     * The values in enum.
     * @desczh
     * 枚举值
     */
    values:t.withDefault(t.array(t.string),[]),
  })
,  t.partial({
    /**
     * You can set a default value for the field
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     * @desczh
     * 缺省值
     */
    defaultValue:t.string,
  })
])
],'MEnumScalar')

/**
 * json
 * @desczh
 * json类型
 */
export const MJsonScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Scalar be used.
     * @desczh
     * 标签判断哪一个Scalar被使用
     */
    _kind:t.literal('json'),
  })
,  t.partial({
    /**
     * You can set a default value for the field
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     * @desczh
     * 缺省值
     */
    defaultValue:t.record(t.string,t.any),
  })
])
],'MJsonScalar')

/**
 * Sring Format
 * @desczh
 * 文本格式
 */
export const MStringFormat = t.keyof({\\"UUID\\":\\"\\",\\"EMail\\":\\"\\",\\"IPV4\\":\\"\\",\\"IPV6\\":\\"\\",\\"URL\\":\\"\\"})
/**
 * A String holds text. This is the type you would use for a username,
 * the content of a blog post or anything else that is best represented as text.
 * @desczh
 * 文本类型
 */
export const MStringScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Scalar be used.
     * @desczh
     * 标签判断哪一个Scalar被使用
     */
    _kind:t.literal('string'),
  })
,  t.partial({
    /**
     * You can set a default value for the field
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     * @desczh
     * 缺省值
     */
    defaultValue:t.string,
    /**
     * The length of value must great than given value
     * @desczh
     * 字段的最小长度
     */
    minLength:t.int,
    /**
     * The length of value must less than given value
     * @desczh
     * 字段的最大长度
     */
    maxLength:t.int,
    /**
     * The length value must match the given pattern
     * @desczh
     * 字段必须匹配这个正则表达式
     */
    pattern:t.string,
    /**
     * The value must match the given format
     * @desczh
     * 字段必须匹配指定的格式
     */
    format:MStringFormat,
  })
])
],'MStringScalar')

/**
 * A Number is a number that can have decimals.
 * Use this to store values such as the price of an item in a store or the result of complex calculations.
 * @desczh
 * 数值型
 */
export const MNumberScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Scalar be used.
     * @desczh
     * 标签判断哪一个Scalar被使用
     */
    _kind:t.literal('number'),
  })
,  t.partial({
    /**
     * You can set a default value for the field
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     * @desczh
     * 缺省值
     */
    defaultValue:t.number,
    /**
     * The value must less than given value
     * @desczh
     * 字段的最大值
     */
    maximum:t.number,
    /**
     * The value must great than given value
     * @desczh
     * 字段的最小值
     */
    minimum:t.number,
  })
])
],'MNumberScalar')

/**
 * An Int is a number that cannot have decimals. 
 * Use this to store values such as the weight of an ingredient required for a recipe or the minimum age for an event.
 * @desczh
 * 整型
 */
export const MIntScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Scalar be used.
     * @desczh
     * 标签判断哪一个Scalar被使用
     */
    _kind:t.literal('int'),
  })
,  t.partial({
    /**
     * You can set a default value for the field
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     * @desczh
     * 缺省值
     */
    defaultValue:t.number,
    /**
     * The value must less than given value
     * @desczh
     * 字段的最大值
     */
    maximum:t.int,
    /**
     * The value must great than given value
     * @desczh
     * 字段的最小值
     */
    minimum:t.int,
  })
])
],'MIntScalar')

/**
 * A Boolean can have the value true or false.
 * This is useful to keep track of settings such as whether the user wants to receive an email newsletter
 * or if a recipe is appropriate for vegetarians.
 * @desczh
 * 布尔型
 */
export const MBooleanScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Scalar be used.
     * @desczh
     * 标签判断哪一个Scalar被使用
     */
    _kind:t.literal('boolean'),
  })
,  t.partial({
    /**
     * You can set a default value for the field
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     * @desczh
     * 缺省值
     */
    defaultValue:t.boolean,
  })
])
],'MBooleanScalar')

/**
 * The DateTime type can be used to store date and/or time values.
 * A good example might be a person's date of birth or the time/data when a specific event is happening.
 * @desczh
 * 日期型
 */
export const MDateTimeScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Scalar be used.
     * @desczh
     * 标签判断哪一个Scalar被使用
     */
    _kind:t.literal('datetime'),
  })
,  t.partial({
    /**
     * You can set a default value for the field
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     * @desczh
     * 缺省值
     */
    defaultValue:t.literal('now'),
  })
])
],'MDateTimeScalar')

/**
 * The _kind is a tag that check which Sclar be used.
 * @desczh
 * 标签
 */
export const MKindScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Scalar be used.
     * @desczh
     * 标签判断哪一个Scalar被使用
     */
    _kind:t.literal('kind'),
    /**
     * kind value
     * @desczh
     * 标签值
     */
    value:t.string,
  })
,  t.partial({
    /**
     * You can set a default value for the field
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     * @desczh
     * 缺省值
     */
    defaultValue:t.string,
  })
])
],'MKindScalar')

/**
 * A type give a value of model types.
 * @desczh
 * 类型
 */
export const MTypeScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Scalar be used.
     * @desczh
     * 标签判断哪一个Scalar被使用
     */
    _kind:t.literal('type'),
    /**
     * Model type name.
     * @desczh
     * 类型名称
     */
    value:t.string,
  })
,  t.partial({
    /**
     * You can set a default value for the field
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     * @desczh
     * 缺省值
     */
    defaultValue:t.string,
  })
])
],'MTypeScalar')

/**
 * A union type describes a value that can be one of several types.
 * @desczh
 * 链接多个类型用OR
 */
export const MTypeUnionScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Scalar be used.
     * @desczh
     * 标签判断哪一个Scalar被使用
     */
    _kind:t.literal('typeUnion'),
    /**
     * Model type name.
     */
    values:t.withDefault(t.array(t.string),[]),
  })
,  t.partial({
    /**
     * You can set a default value for the field
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     * @desczh
     * 缺省值
     */
    defaultValue:t.string,
  })
])
],'MTypeUnionScalar')

/**
 * A intersection type describes a value that can be one of several types.
 * @desczh
 * 链接多个类型用AND
 */
export const MTypeIntersectionScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Scalar be used.
     * @desczh
     * 标签判断哪一个Scalar被使用
     */
    _kind:t.literal('typeIntersection'),
    /**
     * Model type name.
     */
    values:t.withDefault(t.array(t.string),[]),
  })
,  t.partial({
    /**
     * You can set a default value for the field
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     * @desczh
     * 缺省值
     */
    defaultValue:t.string,
  })
])
],'MTypeIntersectionScalar')

/**
 * Scalar
 * @desczh
 * 标量
 */
export const MScalars = t.union([MEnumScalar,MStringScalar,MNumberScalar,MIntScalar,MBooleanScalar,MJsonScalar,MDateTimeScalar,MKindScalar,MTypeScalar,MTypeUnionScalar,MTypeIntersectionScalar])

/**
 * basic scalar
 * @desczh
 * 基本标量
 */
export const MBasicScalar = t.keyof({\\"string\\":\\"\\",\\"number\\":\\"\\",\\"boolean\\":\\"\\",\\"int\\":\\"\\",\\"datetime\\":\\"\\",\\"json\\":\\"\\"})
/**
 * The define a scalar ref
 * @desczh
 * 定义一个标量的引用
 */
export const MValueable =t.type({
  /**
   *  The type of this Node. A value of type indicates a scalar type.
   * @desczh
   * 一个节点的类型
   */
  type:t.withDefault(t.union([MScalars,MBasicScalar])
,\\"string\\"),
  /**
   * The Node can be marked as required (also referred to as \\"non-nullable\\"). 
   * @desczh
   * 是否必填
   */
  required:t.withDefault(t.boolean,false),
})
 
/**
 * Document Tags
 * @desczh
 * 语句注释
 */
export const MDocumentable =t.intersection([  t.type({
    /**
     * That this is no longer the preferred way.
     * @desczh
     * 过时，不再使用
     */
    deprecated:t.withDefault(t.boolean,false),
    /**
     * description
     * @desczh
     * 注释
     */
    description:t.withDefault(t.array(t.string),[]),
    /**
     * Ignore the node when build  docs
     * @desczh
     * 是否在生成文档时跳过
     */
    ignore:t.withDefault(t.boolean,false),
    /**
     * example code
     * @desczh
     * 示例代码
     */
    examples:t.withDefault(t.array(t.string),[]),
    /**
     * That reason of deprecation.
     * @desczh
     * 废弃原因
     */
    reason:t.withDefault(t.array(t.string),[]),
    /**
     * The path on root
     * @desczh
     * 在根目录下的路径
     */
    path:t.withDefault(t.array(t.string),[]),
  })
,  t.partial({
    /**
     * i18n description
     * @desczh
     * 国际化注释
     */
    descriptions:t.record(t.string,t.any),
    /**
     * When was this feature added.
     * @desczh
     * 哪一个版本加入
     */
    since:t.withDefault(t.string,\\"0.2.0\\"),
    /**
     * signature
     * @desczh
     * 签名
     */
    signature:t.string,
  })
])

/**
 * Type have a name field
 * @desczh
 * 有一个name字段
 */
export const MNameable =t.type({
  /**
   * The name is unique
   * @desczh
   * 唯一的名称
   */
  name:t.stringMaxLength(64),
})
 
/**
 *  Represents a field in the datamodel.
 * ModelField is referenced by its name and is either scalar or a relation field.
 * @desczh
 * 表示接口有字段集合
 */
export const MVariable =t.intersection([MDocumentable,MValueable,MNameable,t.type({
})
 ],'MVariable')

/**
 *  Represents a field in the datamodel.
 * Field is referenced by its name and is either scalar or a relation field.
 * @desczh
 * 定义一个字段
 */
export const MField =t.intersection([MVariable,t.type({
  _kind:t.withDefault(t.literal('field'),\\"field\\"),
  /**
   * Setting the unique constraint makes sure that two records of the model in question cannot have the same value for a certain field. 
   * @desczh
   * 唯一.表示这个字段值在模型中不能重复
   */
  unique:t.withDefault(t.boolean,false),
  /**
   * Id in a model\\"). 
   * @desczh
   * 这个字段标明模型的唯一性
   */
  id:t.withDefault(t.boolean,false),
  /**
   * The field create by server.user can not edit
   * @desczh
   * 这个字段值有服务生成，用户不能修改
   */
  readonly:t.withDefault(t.boolean,false),
  /**
   * The field used by order
   * @desczh
   * 可以根据这个字段排序
   */
  order:t.withDefault(t.boolean,true),
  /**
   * That field exclusive when create model.
   * @desczh
   * 字段不在增加操作中使用
   */
  exclusiveCreate:t.withDefault(t.boolean,false),
  /**
   * That field exclusive when update model.
   * @desczh
   * 字段不在更新操作中使用
   */
  exclusiveUpdate:t.withDefault(t.boolean,false),
  /**
   * That field exclusive in where condition.
   * @desczh
   * 字段不在查询条件中
   */
  exclusiveWhere:t.withDefault(t.boolean,false),
  /**
   * That field exclusive in search result.
   * @desczh
   * 字段不在查询结果中
   */
  exclusiveSearch:t.withDefault(t.boolean,false),
  /**
   * That field exclusive in load result.
   * @desczh
   * 字段不在装载结果中
   */
  exclusiveLoad:t.withDefault(t.boolean,false),
})
 ],'MField')

/**
 * Param is used by method.
 * @desczh
 * 函数中的参数定义
 */
export const MParam =t.intersection([MVariable,t.type({
  _kind:t.withDefault(t.literal('param'),\\"param\\"),
})
 ],'MParam')

/**
 * The define a basic function.
 * @desczh
 * 基本函数定义
 */
export const MFunctional =t.intersection([MDocumentable,MValueable,MNameable,t.type({
  /**
   * Param Array
   * @desczh
   * 参数集合
   */
  params:t.withDefault(t.array(MParam),[]),
  /**
   * The means that the method return void 
   * @desczh
   * 是否返回值为void
   */
  returnVoid:t.withDefault(t.boolean,false),
})
 ],'MFunctional')

/**
 * The define a method.
 * @desczh
 * 定义了一个方法
 */
export const MMethod =t.intersection([MFunctional,t.type({
  _kind:t.withDefault(t.literal('method'),\\"method\\"),
})
 ],'MMethod')

/**
 * The define a static method.
 * @desczh
 * 定义了一个静态方法
 */
export const MStaticMethod =t.intersection([MFunctional,t.type({
  _kind:t.withDefault(t.literal('staticmethod'),\\"staticmethod\\"),
})
 ],'MStaticMethod')

/**
 * The Node can export on module
 * @desczh
 * 节点是否在模块导出
 */
export const MExportable =t.type({
  /**
   * This contains tag 'export'
   * @desczh
   * 是否有导出标记
   */
  isExported:t.withDefault(t.boolean,true),
})
 
/**
 * The define a function.
 * @desczh
 * 定义了一个方法
 */
export const MFunction =t.intersection([MFunctional,MExportable,t.type({
  _kind:t.withDefault(t.literal('function'),\\"function\\"),
})
 ],'MFunction')

/**
 * The define a constant.
 * @desczh
 * 定义了一个常量
 */
export const MConstant =t.intersection([MVariable,MExportable,t.type({
  _kind:t.withDefault(t.literal('constant'),\\"constant\\"),
})
 ],'MConstant')

/**
 * The define a export.
 * @desczh
 * 定义了一个Export
 */
export const MExport =t.intersection([MDocumentable,MNameable,t.type({
  _kind:t.withDefault(t.literal('export'),\\"export\\"),
})
 ],'MExport')

/**
 * MTypeable consist of multiple fields and multiple methods
 * @desczh
 * 可类型化表示这个类型由多个字段和方法组成
 */
export const MTypeable =t.intersection([MDocumentable,MExportable,MNameable,t.type({
  /**
   * The define fields on the type.
   * @desczh
   * 字段集合
   */
  fields:t.withDefault(t.array(MField),[]),
  /**
   * The define methods on the type.
   * @desczh
   * 方法集合
   */
  methods:t.withDefault(t.array(MMethod),[]),
})
 ],'MTypeable')

/**
 * The Define a interface
 * @desczh
 * 定义一个接口
 */
export const MInterface =t.intersection([MTypeable,t.type({
  /**
   * kind
   * @desczh
   * 标识
   */
  _kind:t.withDefault(t.literal('interface'),\\"interface\\"),
  /**
   * The names be  implemented by the interface
   * @desczh
   * 实现的接口名称集合
   */
  implements:t.withDefault(t.array(t.string),[]),
})
 ],'MInterface')

/**
 * The Define a Class
 * @desczh
 * 定义一个类
 */
export const MClass =t.intersection([MTypeable,t.type({
  _kind:t.withDefault(t.literal('class'),\\"class\\"),
  /**
   * The names be  implemented by the interface
   * @desczh
   * 实现的接口名称集合
   */
  implements:t.withDefault(t.array(t.string),[]),
  /**
   * Static Method Array
   * @desczh
   * 静态方法集合
   */
  staticMethods:t.withDefault(t.array(MStaticMethod),[]),
})
 ],'MClass')

/**
 * The Define a Type alias
 * @desczh
 * 定义一个类型别名
 */
export const MTypeAlias =t.intersection([MTypeable,MValueable,t.type({
  _kind:t.withDefault(t.literal('typealias'),\\"typealias\\"),
})
 ],'MTypeAlias')

/**
 * The Define a Module
 * @desczh
 * 定义一个Module
 */
export const MModule =t.intersection([MDocumentable,MNameable,t.type({
  /**
   * True mean The module will generate doc
   * @desczh
   * 为真时表示产生文档
   */
  file:t.withDefault(t.boolean,false),
  _kind:t.withDefault(t.literal('module'),\\"module\\"),
  /**
   * interfaces
   * @desczh
   * 接口集合
   */
  interfaces:t.withDefault(t.array(MInterface),[]),
  /**
   * type aliases
   * @desczh
   * 类型别名集合
   */
  typealiases:t.withDefault(t.array(MTypeAlias),[]),
  /**
   * classes
   * @desczh
   * 类集合
   */
  classes:t.withDefault(t.array(MClass),[]),
  /**
   * functions
   * @desczh
   * 函数集合
   */
  functions:t.withDefault(t.array(MFunction),[]),
  /**
   * export
   * @desczh
   * 导出
   */
  exports:t.withDefault(t.array(MExport),[]),
  /**
   * constants
   * @desczh
   * 常量集合
   */
  constants:t.withDefault(t.array(MConstant),[]),
  /**
   * Id field only one
   * @desczh
   * 是否只有一个Id字段
   */
  idUnique:t.withDefault(t.boolean,false),
})
 ],'MModule')

/**
 * type kind
 * @desczh
 * 类型标示
 */
export const MIdentifierKind = t.keyof({\\"field\\":\\"\\",\\"typealias\\":\\"\\",\\"interface\\":\\"\\",\\"class\\":\\"\\",\\"export\\":\\"\\",\\"function\\":\\"\\",\\"param\\":\\"\\",\\"constant\\":\\"\\",\\"module\\":\\"\\",\\"method\\":\\"\\",\\"staticmethod\\":\\"\\"})


"
`;
