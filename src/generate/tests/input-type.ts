/**
 * Code generated by github.com/macoolka/macoolka-gen-model, DO NOT EDIT.
 */
export interface NonEmptyArray<A> extends Array<A> {
    0: A
}


export type BasicScalar = 'string' | 'number' | 'boolean' | 'int' | 'datetime' | 'json'
export type StringFormat = 'UUID' | 'EMail' | 'IPV4' | 'IPV6' | 'URL'
export interface Documentable {
  /**
   * That this is no longer the preferred way.
   */
  deprecated?: boolean
  description?: Array<string>
  file?: Array<string>
  ignore?: Array<string>
  descriptions?: Record<string,any>
  /**
   * When was this feature added.
   */
  since?: string
  examples?: Array<string>
  signature?: string
  /**
   * That reason of deprecation.
   */
  reason?: Array<string>
  path?: Array<string>
}
export interface Modular {
  /**
   * That this is no longer the preferred way.
   */
  isExported?: boolean
}
/**
 * Like a Boolean an Enum can have one of a predefined set of values.
 * The difference is that you can define the possible values
 * (whereas for a Boolean the options are restriced to true and false).
 * For example you could specify how an article should be formatted
 * by creating an Enum with the possible values COMPACT, WIDE and COVER.
 */
export interface EnumScalar {
  /**
   * The _kind is a tag that check which Sclar be used.
   */
  _kind: 'enum'
  values?: Array<string>
  /**
   * You can set a default value for non-list scalar fields.
   * The value will be applied to newly created records when no value was supplied during the create-operation.
   */
  defaultValue?: string
}
export interface JsonScalar {
  /**
   * The _kind is a tag that check which Sclar be used.
   */
  _kind: 'json'
  /**
   * You can set a default value for non-list scalar fields.
   * The value will be applied to newly created records when no value was supplied during the create-operation.
   */
  defaultValue?: string
}
/**
 * A String holds text. This is the type you would use for a username,
 * the content of a blog post or anything else that is best represented as text.
 */
export interface StringScalar {
  _kind: 'string'
  /**
   * You can set a default value for non-list scalar fields.
   * The value will be applied to newly created records when no value was supplied during the create-operation.
   */
  defaultValue?: string
  minLength?: number
  maxLength?: number
  pattern?: string
  format?: StringFormat
}
/**
 * A Number is a number that can have decimals.
 * Use this to store values such as the price of an item in a store or the result of complex calculations.
 */
export interface NumberScalar {
  /**
   * The _kind is a tag that check which Sclar be used.
   */
  _kind: 'number'
  /**
   * You can set a default value for non-list scalar fields.
   * The value will be applied to newly created records when no value was supplied during the create-operation.
   */
  defaultValue?: number
  maximum?: number
  minimum?: number
}
/**
 * An Int is a number that cannot have decimals. 
 * Use this to store values such as the weight of an ingredient required for a recipe or the minimum age for an event.
 */
export interface IntScalar {
  /**
   * The _kind is a tag that check which Sclar be used.
   */
  _kind: 'int'
  /**
   * You can set a default value for non-list scalar fields.
   * The value will be applied to newly created records when no value was supplied during the create-operation.
   */
  defaultValue?: number
  maximum?: number
  minimum?: number
}
/**
 * A Boolean can have the value true or false.
 * This is useful to keep track of settings such as whether the user wants to receive an email newsletter
 * or if a recipe is appropriate for vegetarians.
 */
export interface BooleanScalar {
  /**
   * The _kind is a tag that check which Sclar be used.
   */
  _kind: 'boolean'
  /**
   * You can set a default value for non-list scalar fields.
   * The value will be applied to newly created records when no value was supplied during the create-operation.
   */
  defaultValue?: boolean
}
/**
 * The DateTime type can be used to store date and/or time values.
 * A good example might be a person's date of birth or the time/data when a specific event is happening.
 */
export interface DateTimeScalar {
  /**
   * The _kind is a tag that check which Sclar be used.
   */
  _kind: 'datetime'
  /**
   * You can set a default value for non-list scalar fields.
   * The value will be applied to newly created records when no value was supplied during the create-operation.
   * Now mean current time.
   */
  defaultValue?: 'now'
}
/**
 * The _kind is a tag that check which Sclar be used.
 */
export interface KindScalar {
  /**
   * The _kind is a tag that check which Sclar be used.
   */
  _kind: 'kind'
  value: string
  defaultValue?: string
}
/**
 * A type give a value of model types.
 */
export interface TypeScalar {
  _kind: 'type'
  /**
   * Model type name.
   */
  value: string
  defaultValue?: string
}
/**
 * A union type describes a value that can be one of several types.
 */
export interface TypeUnionScalar {
  _kind: 'typeUnion'
  /**
   * Model type name.
   */
  values?: Array<string>
  defaultValue?: string
}
export interface TypeReference {
  /**
   *  The type of this Node. A value of type indicates a scalar type.
   */
  type?: EnumScalar | StringScalar | NumberScalar | IntScalar | BooleanScalar | JsonScalar | DateTimeScalar | KindScalar | TypeScalar | TypeUnionScalar | BasicScalar
  /**
   * The Node can be marked as required (also referred to as "non-nullable"). 
   */
  required?: boolean
  /**
   * The field has the many multiplicity will also be marked.
   */
  isArray?: boolean
  /**
   * The means that no item in the list can be null
   */
  isArrayRequired?: boolean
  /**
   * The means that defaultValue is []
   */
  defaultEmptyArray?: boolean
}
/**
 *  Represents a field in the datamodel.
 * ModelField is referenced by its name and is either scalar or a relation field.
 */
export interface Field extends Documentable, TypeReference {
  /**
   * The name of field
   * The can only contain alphanumeric characters and need to start with a lowercase letter.
   * They can contain at most 64 characters.
   */
  name: string
  /**
   * Setting the unique constraint makes sure that two records of the model in question cannot have the same value for a certain field. 
   */
  unique?: boolean
  /**
   * Id only one in a model"). 
   */
  id?: boolean
  readonly?: boolean
  order?: boolean
  /**
   * That field exclusive when create operator.
   */
  exclusiveCreate?: boolean
  /**
   * That field exclusive when create update.
   */
  exclusiveUpdate?: boolean
  /**
   * That field exclusive in where condition.
   */
  exclusiveWhere?: boolean
}
/**
 * ModelParam is referenced by its name and is either scalar or a relation field.
 */
export interface Param extends Documentable, TypeReference {
  /**
   * The name of field
   * The can only contain alphanumeric characters and need to start with a lowercase letter.
   * They can contain at most 64 characters.
   */
  name: string
}
/**
 * Method is referenced by its name and is either scalar or a relation field.
 */
export interface Method extends Documentable, TypeReference {
  /**
   * The name of field
   * The can only contain alphanumeric characters and need to start with a lowercase letter.
   * They can contain at most 64 characters.
   */
  name: string
  /**
   * Field can be marked as required (also referred to as "non-nullable"). 
   */
  params?: Array<Param>
  /**
   * The means that the method return void 
   */
  returnVoid?: boolean
}
/**
 * Method is referenced by its name and is either scalar or a relation field.
 */
export interface Function extends Method, Modular {
}
/**
 * Method is referenced by its name and is either scalar or a relation field.
 */
export interface Constant extends Field, Modular {
}
/**
 * Method is referenced by its name and is either scalar or a relation field.
 */
export interface Export extends Documentable {
  name: string
}
/**
 * ModelType consist of multiple fields and typically represent entities from your application domain (e.g. User, Car, Order). 
 * An Model Type defines the structure for one model in your datamodel.
 * It is used to represent entities from your application domain.
 */
export interface Interface extends Documentable, Modular {
  fields?: Array<Field>
  methods?: Array<Method>
  implements?: Array<string>
  /**
   * The name of schema object.
   */
  name: string
}
/**
 * ModelType consist of multiple fields and typically represent entities from your application domain (e.g. User, Car, Order). 
 * An Model Type defines the structure for one model in your datamodel.
 * It is used to represent entities from your application domain.
 */
export interface Class extends Interface, Modular {
  staticMethods?: Array<Method>
}
/**
 * ModelType consist of multiple fields and typically represent entities from your application domain (e.g. User, Car, Order). 
 * An Model Type defines the structure for one model in your datamodel.
 * It is used to represent entities from your application domain.
 */
export interface TypeAlias extends Documentable, TypeReference, Modular {
  fields?: Array<Field>
  methods?: Array<Method>
  /**
   * The name of schema object.
   */
  name: string
}
/**
 * Define the underlying data model schema.
 */
export interface Module extends Documentable {
  interfaces?: Array<Interface>
  typealiases?: Array<TypeAlias>
  classes?: Array<Class>
  functions?: Array<Function>
  exports?: Array<Export>
  constants?: Array<Constant>
  idUnique?: boolean
  /**
   * The name of schema .
   */
  name: string
}


