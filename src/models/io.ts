/**
 * Code generated by github.com/macoolka/macoolka-gen-model, DO NOT EDIT.
 */
import * as t from 'macoolka-io'
export const MBasicScalar = t.keyof({"string":"","number":"","boolean":"","int":"","datetime":"","json":""})
export const MStringFormat = t.keyof({"UUID":"","EMail":"","IPV4":"","IPV6":"","URL":""})
export const MIdentifierKind = t.keyof({"field":"","typealias":"","interface":"","class":"","export":"","function":"","param":"","constant":"","module":"","method":"","staticmethod":""})
export const MNameable =t.type({
  name:t.stringMaxLength(64),
})
 
export const MIdentifier =t.type({
  name:MIdentifierKind,
})
 
export const MDocumentable =t.intersection([  t.type({
    /**
     * That this is no longer the preferred way.
     */
    deprecated:t.withDefault(t.boolean,false),
    description:t.withDefault(t.array(t.string),[]),
    ignore:t.withDefault(t.boolean,false),
    examples:t.withDefault(t.array(t.string),[]),
    /**
     * That reason of deprecation.
     */
    reason:t.withDefault(t.array(t.string),[]),
    path:t.withDefault(t.array(t.string),[]),
  })
,  t.partial({
    descriptions:t.record(t.string,t.any),
    /**
     * When was this feature added.
     */
    since:t.string,
    signature:t.string,
  })
])

export const MExportable =t.type({
  /**
   * That this is no longer the preferred way.
   */
  isExported:t.withDefault(t.boolean,true),
})
 
export const MScalable =t.type({
  /**
   * The Node can be marked as undefined. 
   */
  maybe:t.withDefault(t.boolean,false),
  /**
   * The field has the many multiplicity will also be marked.
   */
  isArray:t.withDefault(t.boolean,false),
  /**
   * The means that no item in the list can be null
   */
  isArrayRequired:t.withDefault(t.boolean,false),
  /**
   * The means that defaultValue is []
   */
  defaultEmptyArray:t.withDefault(t.boolean,true),
})
 
/**
 * Like a Boolean an Enum can have one of a predefined set of values.
 * The difference is that you can define the possible values
 * (whereas for a Boolean the options are restriced to true and false).
 * For example you could specify how an article should be formatted
 * by creating an Enum with the possible values COMPACT, WIDE and COVER.
 */
export const MEnumScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Sclar be used.
     */
    _kind:t.literal('enum'),
    values:t.withDefault(t.array(t.string),[]),
  })
,  t.partial({
    /**
     * You can set a default value for non-list scalar fields.
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     */
    defaultValue:t.string,
  })
])
],'MEnumScalar')

export const MJsonScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Sclar be used.
     */
    _kind:t.literal('json'),
  })
,  t.partial({
    /**
     * You can set a default value for non-list scalar fields.
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     */
    defaultValue:t.record(t.string,t.any),
  })
])
],'MJsonScalar')

/**
 * A String holds text. This is the type you would use for a username,
 * the content of a blog post or anything else that is best represented as text.
 */
export const MStringScalar =t.intersection([MScalable,t.intersection([  t.type({
    _kind:t.literal('string'),
  })
,  t.partial({
    /**
     * You can set a default value for non-list scalar fields.
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     */
    defaultValue:t.string,
    minLength:t.int,
    maxLength:t.int,
    pattern:t.string,
    format:MStringFormat,
  })
])
],'MStringScalar')

/**
 * A Number is a number that can have decimals.
 * Use this to store values such as the price of an item in a store or the result of complex calculations.
 */
export const MNumberScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Sclar be used.
     */
    _kind:t.literal('number'),
  })
,  t.partial({
    /**
     * You can set a default value for non-list scalar fields.
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     */
    defaultValue:t.number,
    maximum:t.number,
    minimum:t.number,
  })
])
],'MNumberScalar')

/**
 * An Int is a number that cannot have decimals. 
 * Use this to store values such as the weight of an ingredient required for a recipe or the minimum age for an event.
 */
export const MIntScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Sclar be used.
     */
    _kind:t.literal('int'),
  })
,  t.partial({
    /**
     * You can set a default value for non-list scalar fields.
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     */
    defaultValue:t.number,
    maximum:t.int,
    minimum:t.int,
  })
])
],'MIntScalar')

/**
 * A Boolean can have the value true or false.
 * This is useful to keep track of settings such as whether the user wants to receive an email newsletter
 * or if a recipe is appropriate for vegetarians.
 */
export const MBooleanScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Sclar be used.
     */
    _kind:t.literal('boolean'),
  })
,  t.partial({
    /**
     * You can set a default value for non-list scalar fields.
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     */
    defaultValue:t.boolean,
  })
])
],'MBooleanScalar')

/**
 * The DateTime type can be used to store date and/or time values.
 * A good example might be a person's date of birth or the time/data when a specific event is happening.
 */
export const MDateTimeScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Sclar be used.
     */
    _kind:t.literal('datetime'),
  })
,  t.partial({
    /**
     * You can set a default value for non-list scalar fields.
     * The value will be applied to newly created records when no value was supplied during the create-operation.
     * Now mean current time.
     */
    defaultValue:t.literal('now'),
  })
])
],'MDateTimeScalar')

/**
 * The _kind is a tag that check which Sclar be used.
 */
export const MKindScalar =t.intersection([MScalable,t.intersection([  t.type({
    /**
     * The _kind is a tag that check which Sclar be used.
     */
    _kind:t.literal('kind'),
    value:t.string,
  })
,  t.partial({
    defaultValue:t.string,
  })
])
],'MKindScalar')

/**
 * A type give a value of model types.
 */
export const MTypeScalar =t.intersection([MScalable,t.intersection([  t.type({
    _kind:t.literal('type'),
    /**
     * Model type name.
     */
    value:t.string,
  })
,  t.partial({
    defaultValue:t.string,
  })
])
],'MTypeScalar')

/**
 * A union type describes a value that can be one of several types.
 */
export const MTypeUnionScalar =t.intersection([MScalable,t.intersection([  t.type({
    _kind:t.literal('typeUnion'),
    /**
     * Model type name.
     */
    values:t.withDefault(t.array(t.string),[]),
  })
,  t.partial({
    defaultValue:t.string,
  })
])
],'MTypeUnionScalar')

/**
 * A intersection type describes a value that can be one of several types.
 */
export const MTypeIntersectionScalar =t.intersection([MScalable,t.intersection([  t.type({
    _kind:t.literal('typeIntersection'),
    /**
     * Model type name.
     */
    values:t.withDefault(t.array(t.string),[]),
  })
,  t.partial({
    defaultValue:t.string,
  })
])
],'MTypeIntersectionScalar')

export const MValueable =t.type({
  /**
   *  The type of this Node. A value of type indicates a scalar type.
   */
  type:t.withDefault(t.union([MEnumScalar,MStringScalar,MNumberScalar,MIntScalar,MBooleanScalar,MJsonScalar,MDateTimeScalar,MKindScalar,MTypeScalar,MTypeUnionScalar,MTypeIntersectionScalar,MBasicScalar])
,"string"),
  /**
   * The Node can be marked as required (also referred to as "non-nullable"). 
   */
  required:t.withDefault(t.boolean,false),
})
 
/**
 *  Represents a field in the datamodel.
 * ModelField is referenced by its name and is either scalar or a relation field.
 */
export const MVariable =t.intersection([MDocumentable,MValueable,MNameable,t.type({
})
 ],'MVariable')

/**
 *  Represents a field in the datamodel.
 * ModelField is referenced by its name and is either scalar or a relation field.
 */
export const MField =t.intersection([MVariable,t.type({
  _kind:t.withDefault(t.literal('field'),"field"),
  /**
   * Setting the unique constraint makes sure that two records of the model in question cannot have the same value for a certain field. 
   */
  unique:t.withDefault(t.boolean,false),
  /**
   * Id only one in a model"). 
   */
  id:t.withDefault(t.boolean,false),
  readonly:t.withDefault(t.boolean,false),
  order:t.withDefault(t.boolean,true),
  /**
   * That field exclusive when create operator.
   */
  exclusiveCreate:t.withDefault(t.boolean,false),
  /**
   * That field exclusive when create update.
   */
  exclusiveUpdate:t.withDefault(t.boolean,false),
  /**
   * That field exclusive in where condition.
   */
  exclusiveWhere:t.withDefault(t.boolean,false),
  /**
   * That field exclusive in search result.
   */
  exclusiveSearch:t.withDefault(t.boolean,false),
  /**
   * That field exclusive in load result.
   */
  exclusiveLoad:t.withDefault(t.boolean,false),
})
 ],'MField')

/**
 * ModelParam is referenced by its name and is either scalar or a relation field.
 */
export const MParam =t.intersection([MVariable,t.type({
  _kind:t.withDefault(t.literal('param'),"param"),
})
 ],'MParam')

/**
 * Method is referenced by its name and is either scalar or a relation field.
 */
export const MFunctional =t.intersection([MDocumentable,MValueable,MNameable,t.type({
  /**
   * Field can be marked as required (also referred to as "non-nullable"). 
   */
  params:t.withDefault(t.array(MParam),[]),
  /**
   * The means that the method return void 
   */
  returnVoid:t.withDefault(t.boolean,false),
})
 ],'MFunctional')

/**
 * Method is referenced by its name and is either scalar or a relation field.
 */
export const MMethod =t.intersection([MFunctional,t.type({
  _kind:t.withDefault(t.literal('method'),"method"),
})
 ],'MMethod')

/**
 * Method is referenced by its name and is either scalar or a relation field.
 */
export const MStaticMethod =t.intersection([MFunctional,t.type({
  _kind:t.withDefault(t.literal('staticmethod'),"staticmethod"),
})
 ],'MStaticMethod')

/**
 * Method is referenced by its name and is either scalar or a relation field.
 */
export const MFunction =t.intersection([MFunctional,MExportable,t.type({
  _kind:t.withDefault(t.literal('function'),"function"),
})
 ],'MFunction')

/**
 * Method is referenced by its name and is either scalar or a relation field.
 */
export const MConstant =t.intersection([MVariable,MExportable,t.type({
  _kind:t.withDefault(t.literal('constant'),"constant"),
})
 ],'MConstant')

/**
 * Method is referenced by its name and is either scalar or a relation field.
 */
export const MExport =t.intersection([MDocumentable,MNameable,t.type({
  _kind:t.withDefault(t.literal('export'),"export"),
})
 ],'MExport')

/**
 * ModelType consist of multiple fields and typically represent entities from your application domain (e.g. User, Car, Order). 
 * An Model Type defines the structure for one model in your datamodel.
 * It is used to represent entities from your application domain.
 */
export const MTypeable =t.intersection([MDocumentable,MExportable,MNameable,t.type({
  fields:t.withDefault(t.array(MField),[]),
  methods:t.withDefault(t.array(MMethod),[]),
})
 ],'MTypeable')

/**
 * ModelType consist of multiple fields and typically represent entities from your application domain (e.g. User, Car, Order). 
 * An Model Type defines the structure for one model in your datamodel.
 * It is used to represent entities from your application domain.
 */
export const MInterface =t.intersection([MTypeable,t.type({
  _kind:t.withDefault(t.literal('interface'),"interface"),
  implements:t.withDefault(t.array(t.string),[]),
})
 ],'MInterface')

/**
 * ModelType consist of multiple fields and typically represent entities from your application domain (e.g. User, Car, Order). 
 * An Model Type defines the structure for one model in your datamodel.
 * It is used to represent entities from your application domain.
 */
export const MClass =t.intersection([MTypeable,t.type({
  _kind:t.withDefault(t.literal('class'),"class"),
  implements:t.withDefault(t.array(t.string),[]),
  staticMethods:t.withDefault(t.array(MStaticMethod),[]),
})
 ],'MClass')

/**
 * ModelType consist of multiple fields and typically represent entities from your application domain (e.g. User, Car, Order). 
 * An Model Type defines the structure for one model in your datamodel.
 * It is used to represent entities from your application domain.
 */
export const MTypeAlias =t.intersection([MTypeable,MValueable,t.type({
  _kind:t.withDefault(t.literal('typealias'),"typealias"),
})
 ],'MTypeAlias')

/**
 * Define the underlying data model schema.
 */
export const MModule =t.intersection([MDocumentable,MNameable,t.type({
  file:t.withDefault(t.boolean,false),
  _kind:t.withDefault(t.literal('module'),"module"),
  interfaces:t.withDefault(t.array(MInterface),[]),
  typealiases:t.withDefault(t.array(MTypeAlias),[]),
  classes:t.withDefault(t.array(MClass),[]),
  functions:t.withDefault(t.array(MFunction),[]),
  exports:t.withDefault(t.array(MExport),[]),
  constants:t.withDefault(t.array(MConstant),[]),
  idUnique:t.withDefault(t.boolean,false),
})
 ],'MModule')



