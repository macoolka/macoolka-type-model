/**
 * Code generated by github.com/macoolka/macoolka-gen-model, DO NOT EDIT.
 */
export interface NonEmptyArray<A> extends Array<A> {
    0: A
}


export type MBasicScalar = 'string' | 'number' | 'boolean' | 'int' | 'datetime' | 'json'
export type MStringFormat = 'UUID' | 'EMail' | 'IPV4' | 'IPV6' | 'URL'
export type MIdentifierKind = 'field' | 'typealias' | 'interface' | 'class' | 'export' | 'function' | 'param' | 'constant' | 'module' | 'method' | 'staticmethod'
export interface MNameable {
  name: string
}
export interface MIdentifier {
  name: MIdentifierKind
}
export interface MDocumentable {
  /**
   * That this is no longer the preferred way.
   */
  deprecated?: boolean
  description?: Array<string>
  ignore?: boolean
  descriptions?: Record<string,any>
  /**
   * When was this feature added.
   */
  since?: string
  examples?: Array<string>
  signature?: string
  /**
   * That reason of deprecation.
   */
  reason?: Array<string>
  path?: Array<string>
}
export interface MExportable {
  /**
   * That this is no longer the preferred way.
   */
  isExported?: boolean
}
export interface MScalable {
  /**
   * The Node can be marked as undefined. 
   */
  maybe?: boolean
  /**
   * The field has the many multiplicity will also be marked.
   */
  isArray?: boolean
  /**
   * The means that no item in the list can be null
   */
  isArrayRequired?: boolean
  /**
   * The means that defaultValue is []
   */
  defaultEmptyArray?: boolean
}
/**
 * Like a Boolean an Enum can have one of a predefined set of values.
 * The difference is that you can define the possible values
 * (whereas for a Boolean the options are restriced to true and false).
 * For example you could specify how an article should be formatted
 * by creating an Enum with the possible values COMPACT, WIDE and COVER.
 */
export interface MEnumScalar extends MScalable {
  /**
   * The _kind is a tag that check which Sclar be used.
   */
  _kind: 'enum'
  values?: Array<string>
  /**
   * You can set a default value for non-list scalar fields.
   * The value will be applied to newly created records when no value was supplied during the create-operation.
   */
  defaultValue?: string
}
export interface MJsonScalar extends MScalable {
  /**
   * The _kind is a tag that check which Sclar be used.
   */
  _kind: 'json'
  /**
   * You can set a default value for non-list scalar fields.
   * The value will be applied to newly created records when no value was supplied during the create-operation.
   */
  defaultValue?: Record<string,any>
}
/**
 * A String holds text. This is the type you would use for a username,
 * the content of a blog post or anything else that is best represented as text.
 */
export interface MStringScalar extends MScalable {
  _kind: 'string'
  /**
   * You can set a default value for non-list scalar fields.
   * The value will be applied to newly created records when no value was supplied during the create-operation.
   */
  defaultValue?: string
  minLength?: number
  maxLength?: number
  pattern?: string
  format?: MStringFormat
}
/**
 * A Number is a number that can have decimals.
 * Use this to store values such as the price of an item in a store or the result of complex calculations.
 */
export interface MNumberScalar extends MScalable {
  /**
   * The _kind is a tag that check which Sclar be used.
   */
  _kind: 'number'
  /**
   * You can set a default value for non-list scalar fields.
   * The value will be applied to newly created records when no value was supplied during the create-operation.
   */
  defaultValue?: number
  maximum?: number
  minimum?: number
}
/**
 * An Int is a number that cannot have decimals. 
 * Use this to store values such as the weight of an ingredient required for a recipe or the minimum age for an event.
 */
export interface MIntScalar extends MScalable {
  /**
   * The _kind is a tag that check which Sclar be used.
   */
  _kind: 'int'
  /**
   * You can set a default value for non-list scalar fields.
   * The value will be applied to newly created records when no value was supplied during the create-operation.
   */
  defaultValue?: number
  maximum?: number
  minimum?: number
}
/**
 * A Boolean can have the value true or false.
 * This is useful to keep track of settings such as whether the user wants to receive an email newsletter
 * or if a recipe is appropriate for vegetarians.
 */
export interface MBooleanScalar extends MScalable {
  /**
   * The _kind is a tag that check which Sclar be used.
   */
  _kind: 'boolean'
  /**
   * You can set a default value for non-list scalar fields.
   * The value will be applied to newly created records when no value was supplied during the create-operation.
   */
  defaultValue?: boolean
}
/**
 * The DateTime type can be used to store date and/or time values.
 * A good example might be a person's date of birth or the time/data when a specific event is happening.
 */
export interface MDateTimeScalar extends MScalable {
  /**
   * The _kind is a tag that check which Sclar be used.
   */
  _kind: 'datetime'
  /**
   * You can set a default value for non-list scalar fields.
   * The value will be applied to newly created records when no value was supplied during the create-operation.
   * Now mean current time.
   */
  defaultValue?: 'now'
}
/**
 * The _kind is a tag that check which Sclar be used.
 */
export interface MKindScalar extends MScalable {
  /**
   * The _kind is a tag that check which Sclar be used.
   */
  _kind: 'kind'
  value: string
  defaultValue?: string
}
/**
 * A type give a value of model types.
 */
export interface MTypeScalar extends MScalable {
  _kind: 'type'
  /**
   * Model type name.
   */
  value: string
  defaultValue?: string
}
/**
 * A union type describes a value that can be one of several types.
 */
export interface MTypeUnionScalar extends MScalable {
  _kind: 'typeUnion'
  /**
   * Model type name.
   */
  values?: Array<string>
  defaultValue?: string
}
/**
 * A intersection type describes a value that can be one of several types.
 */
export interface MTypeIntersectionScalar extends MScalable {
  _kind: 'typeIntersection'
  /**
   * Model type name.
   */
  values?: Array<string>
  defaultValue?: string
}
export interface MValueable {
  /**
   *  The type of this Node. A value of type indicates a scalar type.
   */
  type?: MEnumScalar | MStringScalar | MNumberScalar | MIntScalar | MBooleanScalar | MJsonScalar | MDateTimeScalar | MKindScalar | MTypeScalar | MTypeUnionScalar | MTypeIntersectionScalar | MBasicScalar
  /**
   * The Node can be marked as required (also referred to as "non-nullable"). 
   */
  required?: boolean
}
/**
 *  Represents a field in the datamodel.
 * ModelField is referenced by its name and is either scalar or a relation field.
 */
export interface MVariable extends MDocumentable, MValueable, MNameable {
}
/**
 *  Represents a field in the datamodel.
 * ModelField is referenced by its name and is either scalar or a relation field.
 */
export interface MField extends MVariable {
  _kind?: 'field'
  /**
   * Setting the unique constraint makes sure that two records of the model in question cannot have the same value for a certain field. 
   */
  unique?: boolean
  /**
   * Id only one in a model"). 
   */
  id?: boolean
  readonly?: boolean
  order?: boolean
  /**
   * That field exclusive when create operator.
   */
  exclusiveCreate?: boolean
  /**
   * That field exclusive when create update.
   */
  exclusiveUpdate?: boolean
  /**
   * That field exclusive in where condition.
   */
  exclusiveWhere?: boolean
  /**
   * That field exclusive in search result.
   */
  exclusiveSearch?: boolean
  /**
   * That field exclusive in load result.
   */
  exclusiveLoad?: boolean
}
/**
 * ModelParam is referenced by its name and is either scalar or a relation field.
 */
export interface MParam extends MVariable {
  _kind?: 'param'
}
/**
 * Method is referenced by its name and is either scalar or a relation field.
 */
export interface MFunctional extends MDocumentable, MValueable, MNameable {
  /**
   * Field can be marked as required (also referred to as "non-nullable"). 
   */
  params?: Array<MParam>
  /**
   * The means that the method return void 
   */
  returnVoid?: boolean
}
/**
 * Method is referenced by its name and is either scalar or a relation field.
 */
export interface MMethod extends MFunctional {
  _kind?: 'method'
}
/**
 * Method is referenced by its name and is either scalar or a relation field.
 */
export interface MStaticMethod extends MFunctional {
  _kind?: 'staticmethod'
}
/**
 * Method is referenced by its name and is either scalar or a relation field.
 */
export interface MFunction extends MFunctional, MExportable {
  _kind?: 'function'
}
/**
 * Method is referenced by its name and is either scalar or a relation field.
 */
export interface MConstant extends MVariable, MExportable {
  _kind?: 'constant'
}
/**
 * Method is referenced by its name and is either scalar or a relation field.
 */
export interface MExport extends MDocumentable, MNameable {
  _kind?: 'export'
}
/**
 * ModelType consist of multiple fields and typically represent entities from your application domain (e.g. User, Car, Order). 
 * An Model Type defines the structure for one model in your datamodel.
 * It is used to represent entities from your application domain.
 */
export interface MTypeable extends MDocumentable, MExportable, MNameable {
  fields?: Array<MField>
  methods?: Array<MMethod>
}
/**
 * ModelType consist of multiple fields and typically represent entities from your application domain (e.g. User, Car, Order). 
 * An Model Type defines the structure for one model in your datamodel.
 * It is used to represent entities from your application domain.
 */
export interface MInterface extends MTypeable {
  _kind?: 'interface'
  implements?: Array<string>
}
/**
 * ModelType consist of multiple fields and typically represent entities from your application domain (e.g. User, Car, Order). 
 * An Model Type defines the structure for one model in your datamodel.
 * It is used to represent entities from your application domain.
 */
export interface MClass extends MTypeable {
  _kind?: 'class'
  implements?: Array<string>
  staticMethods?: Array<MStaticMethod>
}
/**
 * ModelType consist of multiple fields and typically represent entities from your application domain (e.g. User, Car, Order). 
 * An Model Type defines the structure for one model in your datamodel.
 * It is used to represent entities from your application domain.
 */
export interface MTypeAlias extends MTypeable, MValueable {
  _kind?: 'typealias'
}
/**
 * Define the underlying data model schema.
 */
export interface MModule extends MDocumentable, MNameable {
  file?: boolean
  _kind?: 'module'
  interfaces?: Array<MInterface>
  typealiases?: Array<MTypeAlias>
  classes?: Array<MClass>
  functions?: Array<MFunction>
  exports?: Array<MExport>
  constants?: Array<MConstant>
  idUnique?: boolean
}


